# -*- coding: utf-8 -*-
"""გაძლიერებული  ალგორითმები.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nBKiZ9uBKnk_jWJ3zf_aOIxknBVGHjkQ
"""

#ამოცანის მიზანი არის  კონკრეტული შერჩეული ალგორითმისთვის ოპტიმალური პარამეტრების ძებნა
#ბადისებრთა ძებნის ალგორითმის გამოყენებით
import pandas as pd
from  sklearn.ensemble import  RandomForestClassifier
from sklearn.model_selection import  train_test_split,GridSearchCV  #ეს არის ბადისებრთა ძებნის ალგორითმი
from sklearn.preprocessing import MinMaxScaler
scaler =MinMaxScaler()
medicine =pd.read_csv("Breast_cancer_data.csv")
model =RandomForestClassifier()
X_train,X_test,y_train,y_test=train_test_split(medicine.drop('diagnosis',axis=1).values,medicine['diagnosis'].values,
                                               test_size=0.2,random_state=1)
#ვახდენთ მონაცემთა სკალირებას
X_train =scaler.fit_transform(X_train)
X_test =scaler.transform(X_test)
#შევქმნათ  ლექსიკონი, სადაც გავუწერეთ n_estimator  ისთვის სხვადასხვა მნიშვნელობებს
parameters ={

             "n_estimators":[20,40,60,80,100,200,300]
}
hybrid =GridSearchCV(estimator=model,param_grid=parameters,scoring='accuracy',n_jobs=-1,
                     cv=5)
#cv  იკითხება როგორც ჯვარედინი შემოწმება  და გულისხმობს მონაცემების დაყოფას რამოდენიმე ტოლ ნაწილად
#ამ შემთხვევაში დაიყოფა 5 ნაწილად და 5 სხვადასხვა სიტუაციაში მოდელი შემოწმდება და გამოითვლება 5  სიზუსტის მაჩვენებელი სიდიდე
hybrid.fit(X_train,y_train)
print(hybrid.best_params_,hybrid.best_score_)

medicine.head()

#ვახდენთ მონაცემთა  ფარდობის შეცვლას
from imblearn.over_sampling import SMOTE
from imblearn.under_sampling import RandomUnderSampler
from imblearn.pipeline import Pipeline
mypipeline=Pipeline(steps=[('over',SMOTE(sampling_strategy=0.85)),('under',RandomUnderSampler(sampling_strategy=0.86)),("model",model)])
mypipeline.fit(X_train,y_train)
print(mypipeline.score(X_test,y_test))

#განმარტება , საწყის მონაცემებში გვქონდა 357  0 კლასის და 212 ი  1 კლასის, sampling_strategy=0.85 ნიშნავს რომ 1 იანების კლასის მონაცემები გაიზრდება ის რომ 1 იანების  რაოდენობა
#გახდება  357*0.85=303  , ხოლო sampling_strategy=0.86  ნიშნავს რომ 0 იანების რაოდენობა შემცირდება იქამდე  რომლის 0.86 იც იქნება  უკვე ახალი მიღებული 1 იანების  რაოდენობა და ეს იქნება
#353  , რადგან 353*0.86=303 და განახლებულ მონაცემებზე უკვე  გაეშვება მოდელი

medicine.shape

medicine['diagnosis'].value_counts()

medicine.isnull().sum()

357*0.85

285/0.2

212/357

353*0.86